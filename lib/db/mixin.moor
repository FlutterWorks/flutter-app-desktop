-- this is the tables.moor file
import 'converter/conversation_category_type_converter.dart';
import 'converter/conversation_status_type_converter.dart';
import 'converter/media_status_type_converter.dart';
import 'converter/message_status_type_converter.dart';
import 'converter/message_category_type_converter.dart';
import 'converter/user_relationship_converter.dart';
import '../enum/conversation_status.dart';
import '../enum/media_status.dart';
import '../enum/message_category.dart';
import '../enum/message_status.dart';

CREATE TABLE addresses ( address_id TEXT NOT NULL, type TEXT NOT NULL, asset_id TEXT NOT NULL, public_key TEXT, label TEXT, updated_at DATETIME NOT NULL, reserve TEXT NOT NULL, fee TEXT NOT NULL, account_name TEXT, account_tag TEXT, dust TEXT, PRIMARY KEY(address_id) );

CREATE TABLE apps (app_id TEXT NOT NULL, app_number TEXT NOT NULL, home_uri TEXT NOT NULL, redirect_uri TEXT NOT NULL, name TEXT NOT NULL, icon_url TEXT NOT NULL, category TEXT, description TEXT NOT NULL, app_secret TEXT NOT NULL, capabilities TEXT, creator_id TEXT NOT NULL, resource_patterns TEXT, updated_at DATETIME, PRIMARY KEY(app_id));

CREATE TABLE assets (asset_id TEXT NOT NULL,symbol TEXT NOT NULL,name TEXT NOT NULL,icon_url TEXT NOT NULL,balance TEXT NOT NULL,destination TEXT NOT NULL,tag TEXT,price_btc TEXT NOT NULL,price_usd TEXT NOT NULL,chain_id TEXT NOT NULL,change_usd TEXT NOT NULL,change_btc TEXT NOT NULL,confirmations INTEGER NOT NULL,asset_key TEXT,PRIMARY KEY(asset_id));

CREATE TABLE circle_conversations ( conversation_id TEXT NOT NULL, circle_id TEXT NOT NULL, user_id TEXT, created_at DATETIME NOT NULL, pin_time DATETIME, PRIMARY KEY(conversation_id, circle_id) );

CREATE TABLE circles ( circle_id TEXT NOT NULL, name TEXT NOT NULL, created_at DATETIME NOT NULL, ordered_at DATETIME, PRIMARY KEY(circle_id) );

CREATE TABLE conversations ( conversation_id TEXT NOT NULL, owner_id TEXT, category TEXT MAPPED BY `const ConversationCategoryTypeConverter()`, name TEXT, icon_url TEXT, announcement TEXT, code_url TEXT, pay_type TEXT, created_at DATETIME NOT NULL, pin_time DATETIME, last_message_id TEXT, last_read_message_id TEXT, unseen_message_count INTEGER, status INTEGER NOT NULL MAPPED BY `const ConversationStatusTypeConverter()`, draft TEXT, mute_until DATETIME, PRIMARY KEY(conversation_id) );

CREATE TABLE flood_messages ( message_id TEXT NOT NULL, data TEXT NOT NULL, created_at DATETIME NOT NULL, PRIMARY KEY(message_id) );

CREATE TABLE hyperlinks ( hyperlink TEXT NOT NULL, site_name TEXT NOT NULL, site_title TEXT NOT NULL, site_description TEXT, site_image TEXT, PRIMARY KEY(hyperlink) );

CREATE TABLE jobs ( job_id TEXT NOT NULL, "action" TEXT NOT NULL, created_at DATETIME NOT NULL, order_id INTEGER, priority INTEGER NOT NULL, user_id TEXT, blaze_message TEXT, conversation_id TEXT, resend_message_id TEXT, run_count INTEGER NOT NULL, PRIMARY KEY(job_id) );

CREATE TABLE message_mentions ( message_id TEXT NOT NULL, conversation_id TEXT NOT NULL, mentions TEXT NOT NULL, has_read INTEGER, PRIMARY KEY(message_id) );

CREATE TABLE messages ( message_id TEXT NOT NULL, conversation_id TEXT NOT NULL, user_id TEXT NOT NULL, category TEXT NOT NULL MAPPED BY `const MessageCategoryTypeConverter()`, content TEXT, media_url TEXT, media_mime_type TEXT, media_size INTEGER, media_duration TEXT, media_width INTEGER, media_height INTEGER, media_hash TEXT, thumb_image TEXT, media_key TEXT, media_digest TEXT, media_status TEXT MAPPED BY `const MediaStatusTypeConverter()`, status TEXT NOT NULL MAPPED BY `const MessageStatusTypeConverter()`, created_at DATETIME NOT NULL, "action" TEXT, participant_id TEXT, snapshot_id TEXT, hyperlink TEXT, name TEXT, album_id TEXT, sticker_id TEXT, shared_user_id TEXT, media_waveform TEXT, quote_message_id TEXT, quote_content TEXT, thumb_url TEXT, PRIMARY KEY(message_id), FOREIGN KEY(conversation_id) REFERENCES conversations(conversation_id) ON UPDATE NO ACTION ON DELETE CASCADE );

CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING FTS5( message_id, conversation_id, content, created_at, user_id, reserved_int, reserved_text, tokenize='unicode61' );

CREATE TABLE messages_history ( message_id TEXT NOT NULL, PRIMARY KEY(message_id) );

CREATE TABLE offsets ( "key" TEXT NOT NULL, timestamp TEXT NOT NULL, PRIMARY KEY("key") );

CREATE TABLE participant_session ( conversation_id TEXT NOT NULL, user_id TEXT NOT NULL, session_id TEXT NOT NULL, sent_to_server INTEGER, created_at DATETIME, PRIMARY KEY(conversation_id, user_id, session_id) );

CREATE TABLE participants ( conversation_id TEXT NOT NULL, user_id TEXT NOT NULL, role TEXT NOT NULL, created_at DATETIME NOT NULL, PRIMARY KEY(conversation_id,user_id), FOREIGN KEY(conversation_id) REFERENCES conversations(conversation_id) ON UPDATE NO ACTION ON DELETE CASCADE );

CREATE TABLE ratchet_sender_keys ( group_id TEXT NOT NULL, sender_id TEXT NOT NULL, status TEXT NOT NULL, message_id TEXT, created_at DATETIME NOT NULL, PRIMARY KEY(group_id, sender_id) );

CREATE TABLE resend_session_messages ( message_id TEXT NOT NULL, user_id TEXT NOT NULL, session_id TEXT NOT NULL, status INTEGER NOT NULL, created_at DATETIME NOT NULL, PRIMARY KEY(message_id, user_id, session_id) );

CREATE TABLE sent_session_sender_keys ( conversation_id TEXT NOT NULL, user_id TEXT NOT NULL, session_id TEXT NOT NULL, sent_to_server INTEGER NOT NULL, sender_key_id INTEGER, created_at DATETIME, PRIMARY KEY(conversation_id,user_id, session_id) );

CREATE TABLE snapshots (snapshot_id TEXT NOT NULL,type TEXT NOT NULL,asset_id TEXT NOT NULL,amount TEXT NOT NULL,created_at DATETIME NOT NULL,opponent_id TEXT,transaction_hash TEXT,sender TEXT,receiver TEXT,memo TEXT,confirmations INTEGER,PRIMARY KEY(snapshot_id));

CREATE TABLE sticker_albums ( album_id TEXT NOT NULL, name TEXT NOT NULL, icon_url TEXT NOT NULL, created_at DATETIME NOT NULL, update_at DATETIME NOT NULL, user_id TEXT NOT NULL, category TEXT NOT NULL, description TEXT NOT NULL, PRIMARY KEY(album_id) );

CREATE TABLE sticker_relationships ( album_id TEXT NOT NULL, sticker_id TEXT NOT NULL, PRIMARY KEY(album_id,sticker_id) );

CREATE TABLE stickers ( sticker_id TEXT NOT NULL, album_id TEXT, name TEXT NOT NULL, asset_url TEXT NOT NULL, asset_type TEXT NOT NULL, asset_width INTEGER NOT NULL, asset_height INTEGER NOT NULL, created_at DATETIME NOT NULL, last_use_at DATETIME, PRIMARY KEY(sticker_id) );

CREATE TABLE users ( user_id TEXT NOT NULL, identity_number TEXT NOT NULL, relationship TEXT NOT NULL MAPPED BY `const UserRelationshipConverter()`, full_name TEXT, avatar_url TEXT, phone TEXT, is_verified INTEGER, created_at DATETIME, mute_until DATETIME, has_pin INTEGER, app_id TEXT, biography TEXT, is_scam INTEGER, PRIMARY KEY(user_id) );

CREATE INDEX IF NOT EXISTS index_jobs_action ON jobs ("action");

CREATE INDEX IF NOT EXISTS index_conversations_category_status_pin_time_created_at ON conversations (category, status, pin_time, created_at);

CREATE INDEX IF NOT EXISTS index_message_mentions_conversation_id ON message_mentions (conversation_id);

CREATE INDEX IF NOT EXISTS index_messages_conversation_id ON messages (conversation_id);
CREATE INDEX IF NOT EXISTS index_messages_conversation_id_created_at ON messages (conversation_id, created_at);
CREATE INDEX IF NOT EXISTS index_messages_conversation_id_status_user_id ON messages (conversation_id, status, user_id);
CREATE INDEX IF NOT EXISTS index_messages_conversation_id_user_id_status_created_at ON messages (conversation_id, user_id, status, created_at);

CREATE INDEX IF NOT EXISTS index_participants_conversation_id ON participants (conversation_id);
CREATE INDEX IF NOT EXISTS index_participants_created_at ON participants (created_at);

CREATE INDEX IF NOT EXISTS index_snapshots_asset_id ON snapshots (asset_id);

CREATE INDEX IF NOT EXISTS index_users_full_name ON users (full_name);

contactConversationCount:
SELECT Count(*)
FROM   conversations c
       INNER JOIN users ou
               ON ou.user_id = c.owner_id
       LEFT JOIN messages m
              ON c.last_message_id = m.message_id
WHERE  c.category = 'CONTACT'
       AND ou.relationship = 'FRIEND'
       AND ou.app_id IS NULL
ORDER  BY c.pin_time DESC,
          CASE
            WHEN m.created_at IS NULL THEN c.created_at
            ELSE m.created_at
          END DESC; 
                      
contactConversations AS ConversationItem:
 SELECT c.conversation_id AS conversationId, c.icon_url AS groupIconUrl, c.category AS category,
            c.name AS groupName, c.status AS status, c.last_read_message_id AS lastReadMessageId,
            c.unseen_message_count AS unseenMessageCount, c.owner_id AS ownerId, c.pin_time AS pinTime, c.mute_until AS muteUntil,
            ou.avatar_url AS avatarUrl, ou.full_name AS name, ou.is_verified AS ownerVerified,
            ou.identity_number AS ownerIdentityNumber, ou.mute_until AS ownerMuteUntil, ou.app_id AS appId,
            m.content AS content, m.category AS contentType, c.created_at AS createdAt, m.created_at AS lastMessageCreatedAt, m.media_url AS mediaUrl,
            m.user_id AS senderId, m.action AS actionName, m.status AS messageStatus,
            mu.full_name AS senderFullName, s.type AS SnapshotType,
            pu.full_name AS participantFullName, pu.user_id AS participantUserId,
            (SELECT count(*) FROM message_mentions me WHERE me.conversation_id = c.conversation_id AND me.has_read = 0) as mentionCount,  
            mm.mentions AS mentions,
            ou.relationship AS relationship 
            FROM conversations c
            INNER JOIN users ou ON ou.user_id = c.owner_id
            LEFT JOIN messages m ON c.last_message_id = m.message_id
            LEFT JOIN message_mentions mm ON mm.message_id = m.message_id
            LEFT JOIN users mu ON mu.user_id = m.user_id
            LEFT JOIN snapshots s ON s.snapshot_id = m.snapshot_id
            LEFT JOIN users pu ON pu.user_id = m.participant_id
            WHERE c.category = 'CONTACT' AND ou.relationship = 'FRIEND' AND ou.app_id IS NULL
            ORDER BY c.pin_time DESC, 
              CASE 
                WHEN m.created_at is NULL THEN c.created_at
                ELSE m.created_at 
              END 
            DESC
            LIMIT :limit OFFSET :offset;

strangerConversationCount:
SELECT Count(*)
FROM   conversations c
       INNER JOIN users ou
               ON ou.user_id = c.owner_id
       LEFT JOIN messages m
              ON c.last_message_id = m.message_id
WHERE  c.category = 'CONTACT'
       AND ou.relationship = 'STRANGER'
ORDER  BY c.pin_time DESC,
          CASE
            WHEN m.created_at IS NULL THEN c.created_at
            ELSE m.created_at
          END DESC; 

strangerConversations AS ConversationItem:
 SELECT c.conversation_id AS conversationId, c.icon_url AS groupIconUrl, c.category AS category,
            c.name AS groupName, c.status AS status, c.last_read_message_id AS lastReadMessageId,
            c.unseen_message_count AS unseenMessageCount, c.owner_id AS ownerId, c.pin_time AS pinTime, c.mute_until AS muteUntil,
            ou.avatar_url AS avatarUrl, ou.full_name AS name, ou.is_verified AS ownerVerified,
            ou.identity_number AS ownerIdentityNumber, ou.mute_until AS ownerMuteUntil, ou.app_id AS appId,
            m.content AS content, m.category AS contentType, c.created_at AS createdAt, m.created_at AS lastMessageCreatedAt, m.media_url AS mediaUrl,
            m.user_id AS senderId, m.action AS actionName, m.status AS messageStatus,
            mu.full_name AS senderFullName, s.type AS SnapshotType,
            pu.full_name AS participantFullName, pu.user_id AS participantUserId,
            (SELECT count(*) FROM message_mentions me WHERE me.conversation_id = c.conversation_id AND me.has_read = 0) as mentionCount,  
            mm.mentions AS mentions,
            ou.relationship AS relationship
            FROM conversations c
            INNER JOIN users ou ON ou.user_id = c.owner_id
            LEFT JOIN messages m ON c.last_message_id = m.message_id
            LEFT JOIN message_mentions mm ON mm.message_id = m.message_id
            LEFT JOIN users mu ON mu.user_id = m.user_id
            LEFT JOIN snapshots s ON s.snapshot_id = m.snapshot_id
            LEFT JOIN users pu ON pu.user_id = m.participant_id
            WHERE c.category = 'CONTACT' AND ou.relationship = 'STRANGER' 
            ORDER BY c.pin_time DESC, 
              CASE 
                WHEN m.created_at is NULL THEN c.created_at
                ELSE m.created_at 
              END 
            DESC
            LIMIT :limit OFFSET :offset;

groupConversationCount:
SELECT Count(*)
FROM   conversations c
       LEFT JOIN messages m
              ON c.last_message_id = m.message_id
WHERE  c.category = 'GROUP'
ORDER  BY c.pin_time DESC,
          CASE
            WHEN m.created_at IS NULL THEN c.created_at
            ELSE m.created_at
          END DESC; 

groupConversations AS ConversationItem:
 SELECT c.conversation_id AS conversationId, c.icon_url AS groupIconUrl, c.category AS category,
            c.name AS groupName, c.status AS status, c.last_read_message_id AS lastReadMessageId,
            c.unseen_message_count AS unseenMessageCount, c.owner_id AS ownerId, c.pin_time AS pinTime, c.mute_until AS muteUntil,
            ou.avatar_url AS avatarUrl, ou.full_name AS name, ou.is_verified AS ownerVerified,
            ou.identity_number AS ownerIdentityNumber, ou.mute_until AS ownerMuteUntil, ou.app_id AS appId,
            m.content AS content, m.category AS contentType, c.created_at AS createdAt, m.created_at AS lastMessageCreatedAt, m.media_url AS mediaUrl,
            m.user_id AS senderId, m.action AS actionName, m.status AS messageStatus,
            mu.full_name AS senderFullName, s.type AS SnapshotType,
            pu.full_name AS participantFullName, pu.user_id AS participantUserId,
            (SELECT count(*) FROM message_mentions me WHERE me.conversation_id = c.conversation_id AND me.has_read = 0) as mentionCount,  
            mm.mentions AS mentions,
            ou.relationship AS relationship 
            FROM conversations c
            INNER JOIN users ou ON ou.user_id = c.owner_id
            LEFT JOIN messages m ON c.last_message_id = m.message_id
            LEFT JOIN message_mentions mm ON mm.message_id = m.message_id
            LEFT JOIN users mu ON mu.user_id = m.user_id
            LEFT JOIN snapshots s ON s.snapshot_id = m.snapshot_id
            LEFT JOIN users pu ON pu.user_id = m.participant_id
            WHERE c.category = 'GROUP' 
            ORDER BY c.pin_time DESC, 
              CASE 
                WHEN m.created_at is NULL THEN c.created_at
                ELSE m.created_at 
              END 
            DESC
            LIMIT :limit OFFSET :offset;

botConversationCount:
SELECT Count(*)
FROM   conversations c
       INNER JOIN users ou
               ON ou.user_id = c.owner_id
       LEFT JOIN messages m
              ON c.last_message_id = m.message_id
WHERE  c.category = 'CONTACT'
       AND ou.app_id IS NOT NULL
ORDER  BY c.pin_time DESC,
          CASE
            WHEN m.created_at IS NULL THEN c.created_at
            ELSE m.created_at
          END DESC; 
          
botConversations AS ConversationItem:
 SELECT c.conversation_id AS conversationId, c.icon_url AS groupIconUrl, c.category AS category,
            c.name AS groupName, c.status AS status, c.last_read_message_id AS lastReadMessageId,
            c.unseen_message_count AS unseenMessageCount, c.owner_id AS ownerId, c.pin_time AS pinTime, c.mute_until AS muteUntil,
            ou.avatar_url AS avatarUrl, ou.full_name AS name, ou.is_verified AS ownerVerified,
            ou.identity_number AS ownerIdentityNumber, ou.mute_until AS ownerMuteUntil, ou.app_id AS appId,
            m.content AS content, m.category AS contentType, c.created_at AS createdAt, m.created_at AS lastMessageCreatedAt, m.media_url AS mediaUrl,
            m.user_id AS senderId, m.action AS actionName, m.status AS messageStatus,
            mu.full_name AS senderFullName, s.type AS SnapshotType,
            pu.full_name AS participantFullName, pu.user_id AS participantUserId,
            (SELECT count(*) FROM message_mentions me WHERE me.conversation_id = c.conversation_id AND me.has_read = 0) as mentionCount,  
            mm.mentions AS mentions,
            ou.relationship AS relationship 
            FROM conversations c
            INNER JOIN users ou ON ou.user_id = c.owner_id
            LEFT JOIN messages m ON c.last_message_id = m.message_id
            LEFT JOIN message_mentions mm ON mm.message_id = m.message_id
            LEFT JOIN users mu ON mu.user_id = m.user_id
            LEFT JOIN snapshots s ON s.snapshot_id = m.snapshot_id
            LEFT JOIN users pu ON pu.user_id = m.participant_id
            WHERE c.category = 'CONTACT' AND ou.app_id IS NOT NULL
            ORDER BY c.pin_time DESC, 
              CASE 
                WHEN m.created_at is NULL THEN c.created_at
                ELSE m.created_at 
              END 
            DESC
            LIMIT :limit OFFSET :offset;

conversationItem AS ConversationItem:
SELECT c.conversation_id AS conversationId, c.icon_url AS groupIconUrl, c.category AS category,
            c.name AS groupName, c.status AS status, c.last_read_message_id AS lastReadMessageId,
            c.unseen_message_count AS unseenMessageCount, c.owner_id AS ownerId, c.pin_time AS pinTime, c.mute_until AS muteUntil,
            ou.avatar_url AS avatarUrl, ou.full_name AS name, ou.is_verified AS ownerVerified,
            ou.identity_number AS ownerIdentityNumber, ou.mute_until AS ownerMuteUntil, ou.app_id AS appId,
            m.content AS content, m.category AS contentType, c.created_at AS createdAt, m.created_at AS lastMessageCreatedAt, m.media_url AS mediaUrl,
            m.user_id AS senderId, m.action AS actionName, m.status AS messageStatus,
            mu.full_name AS senderFullName, s.type AS SnapshotType,
            pu.full_name AS participantFullName, pu.user_id AS participantUserId,
            (SELECT count(*) FROM message_mentions me WHERE me.conversation_id = c.conversation_id AND me.has_read = 0) as mentionCount,  
            mm.mentions AS mentions,
            ou.relationship AS relationship 
            FROM conversations c
            INNER JOIN users ou ON ou.user_id = c.owner_id
            LEFT JOIN messages m ON c.last_message_id = m.message_id
            LEFT JOIN message_mentions mm ON mm.message_id = m.message_id
            LEFT JOIN users mu ON mu.user_id = m.user_id
            LEFT JOIN snapshots s ON s.snapshot_id = m.snapshot_id
            LEFT JOIN users pu ON pu.user_id = m.participant_id
            WHERE c.conversation_id = :id 
                        ORDER BY c.pin_time DESC, 
              CASE 
                WHEN m.created_at is NULL THEN c.created_at
                ELSE m.created_at 
              END 
            DESC;

messagesByConversationId AS MessageItem:
SELECT m.message_id AS messageId, m.conversation_id AS conversationId, u.user_id AS userId,
                        u.full_name AS userFullName, u.identity_number AS userIdentityNumber, u.app_id AS appId, m.category AS type,
                        m.content AS content, m.created_at AS createdAt, m.status AS status, m.media_status AS mediaStatus, m.media_waveform AS mediaWaveform,
                        m.name AS mediaName, m.media_mime_type AS mediaMimeType, m.media_size AS mediaSize, m.media_width AS mediaWidth, m.media_height AS mediaHeight,
                        m.thumb_image AS thumbImage, m.thumb_url AS thumbUrl, m.media_url AS mediaUrl, m.media_duration AS mediaDuration, m.quote_message_id as quoteId,
                        m.quote_content as quoteContent, u1.full_name AS participantFullName, m.action AS actionName, u1.user_id AS participantUserId,
                        s.snapshot_id AS snapshotId, s.type AS snapshotType, s.amount AS snapshotAmount, a.symbol AS assetSymbol, s.asset_id AS assetId,
                        a.icon_url AS assetIcon, st.asset_url AS assetUrl, st.asset_width AS assetWidth, st.asset_height AS assetHeight, st.sticker_id AS stickerId,
                        st.name AS assetName, st.asset_type AS assetType, h.site_name AS siteName, h.site_title AS siteTitle, h.site_description AS siteDescription,
                        h.site_image AS siteImage, m.shared_user_id AS sharedUserId, su.full_name AS sharedUserFullName, su.identity_number AS sharedUserIdentityNumber,
                        su.avatar_url AS sharedUserAvatarUrl, su.is_verified AS sharedUserIsVerified, su.app_id AS sharedUserAppId, mm.mentions AS mentions, mm.has_read as mentionRead, 
                        c.name AS groupName
                        FROM messages m
                        INNER JOIN users u ON m.user_id = u.user_id
                        LEFT JOIN users u1 ON m.participant_id = u1.user_id
                        LEFT JOIN snapshots s ON m.snapshot_id = s.snapshot_id
                        LEFT JOIN assets a ON s.asset_id = a.asset_id
                        LEFT JOIN stickers st ON st.sticker_id = m.sticker_id
                        LEFT JOIN hyperlinks h ON m.hyperlink = h.hyperlink
                        LEFT JOIN users su ON m.shared_user_id = su.user_id
                        LEFT JOIN conversations c ON m.conversation_id = c.conversation_id
                        LEFT JOIN message_mentions mm ON m.message_id = mm.message_id
                        WHERE m.conversation_id = :conversationId 
                        ORDER BY m.created_at DESC
                        LIMIT :offset, :limit;

sendingMessage AS SendingMessage:
SELECT m.message_id, m.conversation_id, m.user_id, m.category, m.content, m.media_url, m.media_mime_type,
      m.media_size, m.media_duration, m.media_width, m.media_height, m.media_hash, m.thumb_image, m.media_key,
      m.media_digest, m.media_status, m.status, m.created_at, m.action, m.participant_id, m.snapshot_id, m.hyperlink,
      m.name, m.album_id, m.sticker_id, m.shared_user_id, m.media_waveform, m.quote_message_id, m.quote_content,
      rm.status as resend_status, rm.user_id as resend_user_id, rm.session_id as resend_session_id
      FROM messages m LEFT JOIN resend_session_messages rm on m.message_id = rm.message_id
      WHERE m.message_id = :message_id AND (m.status = 'SENDING' OR rm.status = 1) AND m.content IS NOT NULL;


participantsAvatar AS UserItem:
SELECT u.user_id,
       u.identity_number,
       u.biography,
       u.full_name,
       u.avatar_url,
       u.relationship
FROM participants p,
     users u
WHERE p.conversation_id = :conversationId
  AND p.user_id = u.user_id
ORDER BY p.created_at
LIMIT 4;